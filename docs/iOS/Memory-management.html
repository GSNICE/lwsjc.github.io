<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>内存管理 | Technology Stack</title>
    <meta name="generator" content="VuePress 1.7.1">
    
    <meta name="description" content="Technology Stack">
    
    <link rel="preload" href="/technology-stack/assets/css/0.styles.e1d3b511.css" as="style"><link rel="preload" href="/technology-stack/assets/js/app.33e0f0b6.js" as="script"><link rel="preload" href="/technology-stack/assets/js/2.fe7261c1.js" as="script"><link rel="preload" href="/technology-stack/assets/js/26.8a472b4b.js" as="script"><link rel="prefetch" href="/technology-stack/assets/js/10.993cb2b7.js"><link rel="prefetch" href="/technology-stack/assets/js/11.3c8be803.js"><link rel="prefetch" href="/technology-stack/assets/js/12.2baf6752.js"><link rel="prefetch" href="/technology-stack/assets/js/13.f5fc67a9.js"><link rel="prefetch" href="/technology-stack/assets/js/14.bd261848.js"><link rel="prefetch" href="/technology-stack/assets/js/15.a92df329.js"><link rel="prefetch" href="/technology-stack/assets/js/16.59346357.js"><link rel="prefetch" href="/technology-stack/assets/js/17.ebd84168.js"><link rel="prefetch" href="/technology-stack/assets/js/18.e488a04c.js"><link rel="prefetch" href="/technology-stack/assets/js/19.8ba4da5f.js"><link rel="prefetch" href="/technology-stack/assets/js/20.3184ef04.js"><link rel="prefetch" href="/technology-stack/assets/js/21.a998311e.js"><link rel="prefetch" href="/technology-stack/assets/js/22.3317584f.js"><link rel="prefetch" href="/technology-stack/assets/js/23.8bb6b234.js"><link rel="prefetch" href="/technology-stack/assets/js/24.65cc23d8.js"><link rel="prefetch" href="/technology-stack/assets/js/25.042e9796.js"><link rel="prefetch" href="/technology-stack/assets/js/27.9b85d2a1.js"><link rel="prefetch" href="/technology-stack/assets/js/28.44a6f02a.js"><link rel="prefetch" href="/technology-stack/assets/js/29.24d98848.js"><link rel="prefetch" href="/technology-stack/assets/js/3.a4745d76.js"><link rel="prefetch" href="/technology-stack/assets/js/30.73398d06.js"><link rel="prefetch" href="/technology-stack/assets/js/31.f47f876c.js"><link rel="prefetch" href="/technology-stack/assets/js/32.20c5d518.js"><link rel="prefetch" href="/technology-stack/assets/js/33.19f61007.js"><link rel="prefetch" href="/technology-stack/assets/js/34.7c784d33.js"><link rel="prefetch" href="/technology-stack/assets/js/35.b60b70de.js"><link rel="prefetch" href="/technology-stack/assets/js/36.caa6aad3.js"><link rel="prefetch" href="/technology-stack/assets/js/37.fe2b45f7.js"><link rel="prefetch" href="/technology-stack/assets/js/4.27e7f231.js"><link rel="prefetch" href="/technology-stack/assets/js/5.cae5ed9c.js"><link rel="prefetch" href="/technology-stack/assets/js/6.1960cf59.js"><link rel="prefetch" href="/technology-stack/assets/js/7.73ad76df.js"><link rel="prefetch" href="/technology-stack/assets/js/8.a4a9c561.js"><link rel="prefetch" href="/technology-stack/assets/js/9.d08e4b5d.js">
    <link rel="stylesheet" href="/technology-stack/assets/css/0.styles.e1d3b511.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/technology-stack/" class="home-link router-link-active"><!----> <span class="site-name">Technology Stack</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/technology-stack/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="http://www.gsnice.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GSNICE
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://blog.csdn.net/u012439446" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Blog
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/GSNICE" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/technology-stack/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="http://www.gsnice.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GSNICE
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://blog.csdn.net/u012439446" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Blog
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/GSNICE" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/technology-stack/docs/Home/" class="sidebar-link">关于</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/technology-stack/docs/Home/#技术栈" class="sidebar-link">技术栈</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/Home/#联系方式" class="sidebar-link">联系方式</a></li></ul></li><li><section class="sidebar-group collapsable depth-0"><a href="/technology-stack/docs/iOS/" class="sidebar-heading clickable router-link-active open"><span>iOS</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/technology-stack/docs/iOS/Animation.html" class="sidebar-link">动画</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Animation.html#_1-uiview动画与核心动画的区别" class="sidebar-link">1.UIView动画与核心动画的区别?</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Animation.html#_2-当我们要做一些基于-calayer-的动画时-有时需要设置-layer-的锚点来配合动画-这时候我们需要注意什么" class="sidebar-link">2.当我们要做一些基于 CALayer 的动画时，有时需要设置 layer 的锚点来配合动画，这时候我们需要注意什么？</a></li></ul></li><li><a href="/technology-stack/docs/iOS/Arithmetic.html" class="sidebar-link">算法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Arithmetic.html#_1-时间复杂度" class="sidebar-link">1.时间复杂度</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Arithmetic.html#_2-空间复杂度" class="sidebar-link">2.空间复杂度</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Arithmetic.html#_3-常用的排序算法" class="sidebar-link">3.常用的排序算法</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Arithmetic.html#_4-字符串反转" class="sidebar-link">4.字符串反转</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Arithmetic.html#_5-链表反转-头差法" class="sidebar-link">5.链表反转（头差法）</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Arithmetic.html#_6-有序数组合并" class="sidebar-link">6.有序数组合并</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Arithmetic.html#_7-查找第一个只出现一次的字符-hash查找" class="sidebar-link">7.查找第一个只出现一次的字符（Hash查找）</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Arithmetic.html#_8-查找两个子视图的共同父视图" class="sidebar-link">8.查找两个子视图的共同父视图</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Arithmetic.html#_9-无序数组中的中位数-快排思想" class="sidebar-link">9.无序数组中的中位数(快排思想)</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Arithmetic.html#_10-给定一个整数数组和一个目标值-找出数组中和为目标值的两个数。" class="sidebar-link">10.给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。</a></li></ul></li><li><a href="/technology-stack/docs/iOS/Code-management.html" class="sidebar-link">代码管理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Code-management.html#_1-svn与git优缺点比较" class="sidebar-link">1.SVN与Git优缺点比较</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Code-management.html#_2-git与svn的区别" class="sidebar-link">2.Git与SVN的区别</a></li></ul></li><li><a href="/technology-stack/docs/iOS/Component-based.html" class="sidebar-link">组件化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Component-based.html#_1-组件化有什么好处" class="sidebar-link">1.组件化有什么好处？</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Component-based.html#_2-你是如何组件化解耦的" class="sidebar-link">2.你是如何组件化解耦的？</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Component-based.html#_3-为什么ctmediator方案优于基于router的方案" class="sidebar-link">3.为什么CTMediator方案优于基于Router的方案？</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Component-based.html#_4-基于ctmediator的组件化方案-有哪些核心组成" class="sidebar-link">4.基于CTMediator的组件化方案，有哪些核心组成？</a></li></ul></li><li><a href="/technology-stack/docs/iOS/Continuous-integration.html" class="sidebar-link">持续集成</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Continuous-integration.html#_1-你在项目中使用过什么持续集成方式" class="sidebar-link">1.你在项目中使用过什么持续集成方式？</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Continuous-integration.html#_2-jenkins怎么备份恢复" class="sidebar-link">2.jenkins怎么备份恢复</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Continuous-integration.html#_3-jenkins你都用了哪些插件" class="sidebar-link">3.jenkins你都用了哪些插件？</a></li></ul></li><li><a href="/technology-stack/docs/iOS/Data-encryption.html" class="sidebar-link">数据安全及加密</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Data-encryption.html#_1-对称加密和非对称加密的区别" class="sidebar-link">1.对称加密和非对称加密的区别？</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Data-encryption.html#_2-简述-ssl-加密的过程用了哪些加密方法-为何这么作" class="sidebar-link">2.简述 SSL 加密的过程用了哪些加密方法，为何这么作？</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Data-encryption.html#_3-ios的签名机制是怎么样的" class="sidebar-link">3.iOS的签名机制是怎么样的</a></li></ul></li><li><a href="/technology-stack/docs/iOS/Data-storage.html" class="sidebar-link">数据存储</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Data-storage.html#_1-ios-开发中数据持久性有哪几种" class="sidebar-link">1.iOS 开发中数据持久性有哪几种?</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Data-storage.html#_2-fmdb数据结构变化升级" class="sidebar-link">2.FMDB数据结构变化升级</a></li></ul></li><li><a href="/technology-stack/docs/iOS/Data-structure.html" class="sidebar-link">数据结构</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Data-structure.html#_1-数据结构的存储一般常用的有几种-各有什么特点" class="sidebar-link">1.数据结构的存储一般常用的有几种？各有什么特点？</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Data-structure.html#_2-集合结构-线性结构-树形结构-图形结构" class="sidebar-link">2.集合结构 线性结构 树形结构 图形结构</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Data-structure.html#_3-单向链表-双向链表-循环链表" class="sidebar-link">3.单向链表 双向链表 循环链表</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Data-structure.html#_4-数组和链表区别" class="sidebar-link">4.数组和链表区别</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Data-structure.html#_5-堆、栈和队列" class="sidebar-link">5.堆、栈和队列</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Data-structure.html#_6-输入一棵二叉树的根结点-求该树的深度" class="sidebar-link">6.输入一棵二叉树的根结点，求该树的深度？</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Data-structure.html#_7-输入一课二叉树的根结点-判断该树是不是平衡二叉树" class="sidebar-link">7.输入一课二叉树的根结点，判断该树是不是平衡二叉树？</a></li></ul></li><li><a href="/technology-stack/docs/iOS/Debug-tips.html" class="sidebar-link">调试技巧</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Debug-tips.html#_1-lldb常用的调试命令" class="sidebar-link">1.LLDB常用的调试命令？</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Debug-tips.html#_2-断点调试" class="sidebar-link">2.断点调试</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Debug-tips.html#_3-ios-常见的崩溃类型有哪些" class="sidebar-link">3.iOS 常见的崩溃类型有哪些？</a></li></ul></li><li><a href="/technology-stack/docs/iOS/Design-patterns.html" class="sidebar-link">设计模式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Design-patterns.html#_1-ios有哪些常见的设计模式" class="sidebar-link">1.iOS有哪些常见的设计模式?</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Design-patterns.html#_2-单例会有什么弊端" class="sidebar-link">2.单例会有什么弊端？</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Design-patterns.html#_3-编程中的六大设计原则" class="sidebar-link">3.编程中的六大设计原则？</a></li></ul></li><li><a href="/technology-stack/docs/iOS/Image-processing.html" class="sidebar-link">图像处理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Image-processing.html#_1-图像的压缩方式" class="sidebar-link">1.图像的压缩方式</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Image-processing.html#_2-如何计算图片加载内存中所占的大小" class="sidebar-link">2.如何计算图片加载内存中所占的大小</a></li></ul></li><li><a href="/technology-stack/docs/iOS/Memory-management.html" aria-current="page" class="active sidebar-link">内存管理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Memory-management.html#_1-什么情况使用weak关键字-相比assign有什么不同" class="sidebar-link">1.什么情况使用weak关键字，相比assign有什么不同？</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Memory-management.html#_2-如何让自己的类用copy修饰符-如何重写带copy关键字的setter" class="sidebar-link">2.如何让自己的类用copy修饰符？如何重写带copy关键字的setter？</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Memory-management.html#_3-深拷贝与浅拷贝" class="sidebar-link">3.深拷贝与浅拷贝</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Memory-management.html#_4-property的本质是什么-ivar、getter、setter是如何生成并添加到这个类中的" class="sidebar-link">4.@property的本质是什么？ivar、getter、setter是如何生成并添加到这个类中的</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Memory-management.html#_5-protocol和category中如何使用-property" class="sidebar-link">5.@protocol和category中如何使用@property</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Memory-management.html#_6-简要说一下-autoreleasepool的数据结构" class="sidebar-link">6.简要说一下@autoreleasePool的数据结构？？</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Memory-management.html#_7-bad-access在什么情况下出现" class="sidebar-link">7.BAD_ACCESS在什么情况下出现？</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Memory-management.html#_8-使用cadisplaylink、nstimer有什么注意点" class="sidebar-link">8.使用CADisplayLink、NSTimer有什么注意点？</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Memory-management.html#_9-ios内存分区情况" class="sidebar-link">9.iOS内存分区情况</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Memory-management.html#_10-ios内存管理方式" class="sidebar-link">10.iOS内存管理方式</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Memory-management.html#_11-循环引用" class="sidebar-link">11.循环引用</a></li></ul></li><li><a href="/technology-stack/docs/iOS/Message-passing.html" class="sidebar-link">消息传递的方式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Message-passing.html#_1-kvc实现原理" class="sidebar-link">1.KVC实现原理</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Message-passing.html#_2-kvo的实现原理" class="sidebar-link">2.KVO的实现原理</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Message-passing.html#_3-如何手动触发kvo方法" class="sidebar-link">3.如何手动触发KVO方法</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Message-passing.html#_4-通知和代理有什么区别" class="sidebar-link">4.通知和代理有什么区别</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Message-passing.html#_5-block和delegate的区别" class="sidebar-link">5.block和delegate的区别</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Message-passing.html#_6-为什么block用copy关键字" class="sidebar-link">6.为什么Block用copy关键字</a></li></ul></li><li><a href="/technology-stack/docs/iOS/Multi-thread.html" class="sidebar-link">多线程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Multi-thread.html#_1-进程与线程" class="sidebar-link">1.进程与线程</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Multi-thread.html#_2-什么是多线程" class="sidebar-link">2.什么是多线程？</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Multi-thread.html#_3-多线程的优点和缺点" class="sidebar-link">3.多线程的优点和缺点</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Multi-thread.html#_4-多线程的-并行-和-并发-有什么区别" class="sidebar-link">4.多线程的 并行 和 并发 有什么区别？</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Multi-thread.html#_5-ios中实现多线程的几种方案-各自有什么特点" class="sidebar-link">5.iOS中实现多线程的几种方案，各自有什么特点？</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Multi-thread.html#_6-多个网络请求完成后执行下一步" class="sidebar-link">6.多个网络请求完成后执行下一步</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Multi-thread.html#_7-多个网络请求顺序执行后执行下一步" class="sidebar-link">7.多个网络请求顺序执行后执行下一步</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Multi-thread.html#_8-异步操作两组数据时-执行完第一组之后-才能执行第二组" class="sidebar-link">8.异步操作两组数据时, 执行完第一组之后, 才能执行第二组</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Multi-thread.html#_9-多线程中的死锁" class="sidebar-link">9.多线程中的死锁？</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Multi-thread.html#_10-gcd执行原理" class="sidebar-link">10.GCD执行原理？</a></li></ul></li><li><a href="/technology-stack/docs/iOS/Network.html" class="sidebar-link">网络</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Network.html#_1-网络七层协议" class="sidebar-link">1.网络七层协议</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Network.html#_2-http-和-https-的区别-https为什么更加安全" class="sidebar-link">2.Http 和 Https 的区别？Https为什么更加安全？</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Network.html#_3-https的连接建立流程" class="sidebar-link">3.HTTPS的连接建立流程</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Network.html#_4-解释一下-三次握手-和-四次挥手" class="sidebar-link">4.解释一下 三次握手 和 四次挥手</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Network.html#_5-tcp-和-udp的区别" class="sidebar-link">5.TCP 和 UDP的区别</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Network.html#_6-cookie和session" class="sidebar-link">6.Cookie和Session</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Network.html#_7-dns是什么" class="sidebar-link">7.DNS是什么</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Network.html#_8-dns解析过程" class="sidebar-link">8.DNS解析过程</a></li></ul></li><li><a href="/technology-stack/docs/iOS/Performance-optimization.html" class="sidebar-link">性能优化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Performance-optimization.html#_1-造成tableview卡顿的原因有哪些" class="sidebar-link">1.造成tableView卡顿的原因有哪些？</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Performance-optimization.html#_2-如何提升-tableview-的流畅度" class="sidebar-link">2.如何提升 tableview 的流畅度？</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Performance-optimization.html#_3-app启动时间应从哪些方面优化" class="sidebar-link">3.APP启动时间应从哪些方面优化？</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Performance-optimization.html#_4-如何降低app包的大小" class="sidebar-link">4.如何降低APP包的大小</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Performance-optimization.html#_5-如何检测离屏渲染与优化" class="sidebar-link">5.如何检测离屏渲染与优化</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Performance-optimization.html#_6-怎么检测图层混合" class="sidebar-link">6.怎么检测图层混合</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Performance-optimization.html#_7-日常如何检查内存泄露" class="sidebar-link">7.日常如何检查内存泄露？</a></li></ul></li><li><a href="/technology-stack/docs/iOS/Project-organization.html" class="sidebar-link">项目架构</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Project-organization.html#_1-mvc、mvp、mvvm模式" class="sidebar-link">1.MVC、MVP、MVVM模式</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Project-organization.html#_2-关于rac你有怎样运用到解决不同api依赖关系" class="sidebar-link">2.关于RAC你有怎样运用到解决不同API依赖关系</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Project-organization.html#_3-weakify和我们宏定义的weakself有什么区别" class="sidebar-link">3.@weakify和我们宏定义的WeakSelf有什么区别？</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Project-organization.html#_4-微服务架构设想。" class="sidebar-link">4.微服务架构设想。</a></li></ul></li><li><a href="/technology-stack/docs/iOS/Runloop.html" class="sidebar-link">Runloop</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Runloop.html#_1-runloop-和线程的关系" class="sidebar-link">1.Runloop 和线程的关系？</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Runloop.html#_2-runloop的运行模式" class="sidebar-link">2.RunLoop的运行模式</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Runloop.html#_3-runloop内部逻辑" class="sidebar-link">3.runloop内部逻辑？</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Runloop.html#_4-autoreleasepool-在何时被释放" class="sidebar-link">4.autoreleasePool 在何时被释放？</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Runloop.html#_5-gcd-在runloop中的使用" class="sidebar-link">5.GCD 在Runloop中的使用？</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Runloop.html#_6-afnetworking-中如何运用-runloop" class="sidebar-link">6.AFNetworking 中如何运用 Runloop?</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Runloop.html#_7-performselector-的实现原理" class="sidebar-link">7.PerformSelector 的实现原理？</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Runloop.html#_8-performselector-afterdelay-这个方法在子线程中是否起作用" class="sidebar-link">8.PerformSelector:afterDelay:这个方法在子线程中是否起作用？</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Runloop.html#_9-事件响应的过程" class="sidebar-link">9.事件响应的过程？</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Runloop.html#_10-手势识别的过程" class="sidebar-link">10.手势识别的过程？</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Runloop.html#_11-cadispalytimer和timer哪个更精确" class="sidebar-link">11.CADispalyTimer和Timer哪个更精确</a></li></ul></li><li><a href="/technology-stack/docs/iOS/Runtime.html" class="sidebar-link">Runtime</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Runtime.html#_1-category-的实现原理" class="sidebar-link">1.Category 的实现原理？</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Runtime.html#_2-isa指针的理解-对象的isa指针指向哪里-isa指针有哪两种类型" class="sidebar-link">2.isa指针的理解，对象的isa指针指向哪里？isa指针有哪两种类型？</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Runtime.html#_3-objective-c-如何实现多重继承" class="sidebar-link">3.Objective-C 如何实现多重继承？</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Runtime.html#_4-runtime-如何实现-weak-属性" class="sidebar-link">4.runtime 如何实现 weak 属性？</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Runtime.html#_5-讲一下-oc-的消息机制" class="sidebar-link">5.讲一下 OC 的消息机制</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Runtime.html#_6-runtime具体应用" class="sidebar-link">6.runtime具体应用</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Runtime.html#_7-runtime如何通过selector找到对应的imp地址" class="sidebar-link">7.runtime如何通过selector找到对应的IMP地址？</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Runtime.html#_8-简述下objective-c中调用方法的过程" class="sidebar-link">8.简述下Objective-C中调用方法的过程</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Runtime.html#_9-load和initialize的区别" class="sidebar-link">9.load和initialize的区别</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Runtime.html#_10-怎么理解objective-c是动态运行时语言。" class="sidebar-link">10.怎么理解Objective-C是动态运行时语言。</a></li></ul></li><li><a href="/technology-stack/docs/iOS/Source-code.html" class="sidebar-link">源码理解</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Source-code.html#_1-yykit" class="sidebar-link">1.YYKit</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Source-code.html#_2-sdwebimage加载图片过程" class="sidebar-link">2.SDWebImage加载图片过程</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Source-code.html#_3-yywebimage和sdwebimage对比" class="sidebar-link">3.YYWebImage和SDWebImage对比</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/Source-code.html#_4-afnetworking-底层原理分析" class="sidebar-link">4.AFNetworking 底层原理分析</a></li></ul></li><li><a href="/technology-stack/docs/iOS/UIKit.html" class="sidebar-link">UIKit</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/UIKit.html#_1-uiview-和-calayer-是什么关系" class="sidebar-link">1.UIView 和 CALayer 是什么关系？</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/UIKit.html#_2-bounds-和-frame-的区别" class="sidebar-link">2.Bounds 和 Frame 的区别?</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/UIKit.html#_3-setneedsdisplay-和-layoutifneeded-两者是什么关系" class="sidebar-link">3.setNeedsDisplay 和 layoutIfNeeded 两者是什么关系？</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/UIKit.html#_4-谈谈对uiresponder的理解" class="sidebar-link">4.谈谈对UIResponder的理解</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/UIKit.html#_5-loadview的作用" class="sidebar-link">5.loadView的作用？</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/UIKit.html#_6-使用-drawrect有什么影响" class="sidebar-link">6.使用 drawRect有什么影响？</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/UIKit.html#_7-keywindow-和-delegate的window有何区别" class="sidebar-link">7.keyWindow 和 delegate的window有何区别</a></li></ul></li><li><a href="/technology-stack/docs/iOS/WebView.html" class="sidebar-link">WebView</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/WebView.html#_1-说一下-js-和-oc-互相调用的几种方式" class="sidebar-link">1.说一下 JS 和 OC 互相调用的几种方式？</a></li><li class="sidebar-sub-header"><a href="/technology-stack/docs/iOS/WebView.html#_2-在使用-wkwedview-时遇到过哪些问题" class="sidebar-link">2.在使用 WKWedView 时遇到过哪些问题？</a></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/technology-stack/docs/Android/" class="sidebar-heading clickable"><span>Android</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/technology-stack/docs/Flutter/" class="sidebar-heading clickable"><span>Flutter</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/technology-stack/docs/Vue/" class="sidebar-heading clickable"><span>Vue</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/technology-stack/docs/PHP/" class="sidebar-heading clickable"><span>PHP</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/technology-stack/docs/Python/" class="sidebar-heading clickable"><span>Python</span> <span class="arrow right"></span></a> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="内存管理"><a href="#内存管理" class="header-anchor">#</a> 内存管理</h1> <h2 id="_1-什么情况使用weak关键字-相比assign有什么不同"><a href="#_1-什么情况使用weak关键字-相比assign有什么不同" class="header-anchor">#</a> 1.什么情况使用weak关键字，相比assign有什么不同？</h2> <ul><li><p>什么情况使用 weak 关键字？</p> <p>在 ARC 中,在有可能出现循环引用的时候,往往要通过让其中一端使用 weak 来解决,比如: delegate 代理属性</p> <p>自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用 weak,自定义 IBOutlet 控件属性一般也使用 weak；当然，也可以使用strong。在下文也有论述：《IBOutlet连出来的视图属性为什么可以被设置成weak?》</p></li> <li><p>不同点：</p> <p>weak 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同assign类似， 然而在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。 而 assign 的“设置方法”只会执行针对“纯量类型” (scalar type，例如 CGFloat 或 NSlnteger 等)的简单赋值操作。</p> <p>assign 可以用非 OC 对象,而 weak 必须用于 OC 对象</p></li></ul> <h2 id="_2-如何让自己的类用copy修饰符-如何重写带copy关键字的setter"><a href="#_2-如何让自己的类用copy修饰符-如何重写带copy关键字的setter" class="header-anchor">#</a> 2.如何让自己的类用copy修饰符？如何重写带copy关键字的setter？</h2> <ul><li><p>若想令自己所写的对象具有拷贝功能，则需实现 NSCopying 协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现 NSCopying 与 NSMutableCopying 协议。</p> <p>具体步骤：</p> <p>需声明该类遵从 NSCopying 协议</p> <p>实现 NSCopying 协议。该协议只有一个方法:</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token operator">-</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span>copyWithZone<span class="token operator">:</span><span class="token punctuation">(</span>NSZone <span class="token operator">*</span><span class="token punctuation">)</span>zone<span class="token punctuation">;</span>
</code></pre></div><p>注意：一提到让自己的类用 copy 修饰符，我们总是想覆写copy方法，其实真正需要实现的却是 “copyWithZone” 方法。</p></li> <li><p>重写带 copy 关键字的 setter，例如：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>setName<span class="token operator">:</span><span class="token punctuation">(</span>NSString <span class="token operator">*</span><span class="token punctuation">)</span>name <span class="token punctuation">{</span>
    <span class="token comment">//[_name release];</span>
    _name <span class="token operator">=</span> <span class="token punctuation">[</span>name copy<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h2 id="_3-深拷贝与浅拷贝"><a href="#_3-深拷贝与浅拷贝" class="header-anchor">#</a> 3.深拷贝与浅拷贝</h2> <p>浅拷贝只是对指针的拷贝，拷贝后两个指针指向同一个内存空间，深拷贝不但对指针进行拷贝，而且对指针指向的内容进行拷贝，经深拷贝后的指针是指向两个不同地址的指针。</p> <p>当对象中存在指针成员时，除了在复制对象时需要考虑自定义拷贝构造函数，还应该考虑以下两种情形：</p> <ul><li><p>当函数的参数为对象时，实参传递给形参的实际上是实参的一个拷贝对象，系统自动通过拷贝构造函数实现；</p></li> <li><p>当函数的返回值为一个对象时，该对象实际上是函数内对象的一个拷贝，用于返回函数调用处。</p></li></ul> <p>copy方法:如果是非可扩展类对象，则是浅拷贝。如果是可扩展类对象，则是深拷贝。</p> <p>mutableCopy方法:无论是可扩展类对象还是不可扩展类对象，都是深拷贝。</p> <h2 id="_4-property的本质是什么-ivar、getter、setter是如何生成并添加到这个类中的"><a href="#_4-property的本质是什么-ivar、getter、setter是如何生成并添加到这个类中的" class="header-anchor">#</a> 4.@property的本质是什么？ivar、getter、setter是如何生成并添加到这个类中的</h2> <ul><li><p>@property 的本质是实例变量（ivar）+存取方法（access method ＝ getter + setter）,即 @property = ivar + getter + setter;</p> <p>“属性” (property)作为 Objective-C 的一项特性，主要的作用就在于封装对象中的数据。 Objective-C 对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”(access method)来访问。其中，“获取方法” (getter)用于读取变量值，而“设置方法” (setter)用于写入变量值。</p></li> <li><p>ivar、getter、setter 是自动合成这个类中的</p> <p>完成属性定义后，编译器会自动编写访问这些属性所需的方法，此过程叫做“自动合成”(autosynthesis)。需要强调的是，这个过程由编译 器在编译期执行，所以编辑器里看不到这些“合成方法”(synthesized method)的源代码。除了生成方法代码 getter、setter 之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。在前例中，会生成两个实例变量，其名称分别为 _firstName 与 _lastName。也可以在类的实现代码里通过 @synthesize 语法来指定实例变量的名字.</p></li></ul> <h2 id="_5-protocol和category中如何使用-property"><a href="#_5-protocol和category中如何使用-property" class="header-anchor">#</a> 5.@protocol和category中如何使用@property</h2> <ul><li><p>在 protocol 中使用 property 只会生成 setter 和 getter 方法声明,我们使用属性的目的,是希望遵守我协议的对象能实现该属性</p></li> <li><p>category 使用 @property 也是只会生成 setter 和 getter 方法的声明,如果我们真的需要给 category 增加属性的实现,需要借助于运行时的两个函数：objc_setAssociatedObject和objc_getAssociatedObject</p></li></ul> <h2 id="_6-简要说一下-autoreleasepool的数据结构"><a href="#_6-简要说一下-autoreleasepool的数据结构" class="header-anchor">#</a> 6.简要说一下@autoreleasePool的数据结构？？</h2> <p>简单说是双向链表，每张链表头尾相接，有 parent、child指针</p> <p>每创建一个池子，会在首部创建一个 哨兵 对象,作为标记</p> <p>最外层池子的顶端会有一个next指针。当链表容量满了，就会在链表的顶端，并指向下一张表。</p> <h2 id="_7-bad-access在什么情况下出现"><a href="#_7-bad-access在什么情况下出现" class="header-anchor">#</a> 7.BAD_ACCESS在什么情况下出现？</h2> <p>访问了悬垂指针，比如对一个已经释放的对象执行了release、访问已经释放对象的成员变量或者发消息。 死循环</p> <h2 id="_8-使用cadisplaylink、nstimer有什么注意点"><a href="#_8-使用cadisplaylink、nstimer有什么注意点" class="header-anchor">#</a> 8.使用CADisplayLink、NSTimer有什么注意点？</h2> <p>CADisplayLink、NSTimer会造成循环引用，可以使用YYWeakProxy或者为CADisplayLink、NSTimer添加block方法解决循环引用</p> <h2 id="_9-ios内存分区情况"><a href="#_9-ios内存分区情况" class="header-anchor">#</a> 9.iOS内存分区情况</h2> <ul><li><p>栈区（Stack）</p> <p>由编译器自动分配释放，存放函数的参数，局部变量的值等</p> <p>栈是向低地址扩展的数据结构，是一块连续的内存区域</p></li> <li><p>堆区（Heap）</p> <p>由程序员分配释放</p> <p>是向高地址扩展的数据结构，是不连续的内存区域</p></li> <li><p>全局区</p> <p>全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域</p> <p>程序结束后由系统释放</p></li> <li><p>常量区</p> <p>常量字符串就是放在这里的</p> <p>程序结束后由系统释放</p></li> <li><p>代码区</p> <p>存放函数体的二进制代码</p></li> <li><p>注：</p> <ul><li><p>在 iOS 中，堆区的内存是应用程序共享的，堆中的内存分配是系统负责的</p></li> <li><p>系统使用一个链表来维护所有已经分配的内存空间（系统仅仅记录，并不管理具体的内容）</p></li> <li><p>变量使用结束后，需要释放内存，OC 中是判断引用计数是否为 0，如果是就说明没有任何变量使用该空间，那么系统将其回收</p></li> <li><p>当一个 app 启动后，代码区、常量区、全局区大小就已经固定，因此指向这些区的指针不会产生崩溃性的错误。而堆区和栈区是时时刻刻变化的（堆的创建销毁，栈的弹入弹出），所以当使用一个指针指向这个区里面的内存时，一定要注意内存是否已经被释放，否则会产生程序崩溃（也即是野指针报错）</p></li></ul></li></ul> <h2 id="_10-ios内存管理方式"><a href="#_10-ios内存管理方式" class="header-anchor">#</a> 10.iOS内存管理方式</h2> <ul><li><p>Tagged Pointer（小对象）</p> <p>Tagged Pointer 专门用来存储小的对象，例如 NSNumber 和 NSDate</p> <p>Tagged Pointer 指针的值不再是地址了，而是真正的值。所以，实际上它不再是一个对象了，它只是一个披着对象皮的普通变量而已。所以，它的内存并不存储在堆中，也不需要 malloc 和 free</p> <p>在内存读取上有着 3 倍的效率，创建时比以前快 106 倍</p> <p>objc_msgSend 能识别 Tagged Pointer，比如 NSNumber 的 intValue 方法，直接从指针提取数据</p> <p>使用 Tagged Pointer 后，指针内存储的数据变成了 Tag + Data，也就是将数据直接存储在了指针中</p></li> <li><p>NONPOINTER_ISA （指针中存放与该对象内存相关的信息）
苹果将 isa 设计成了联合体，在 isa 中存储了与该对象相关的一些内存的信息，原因也如上面所说，并不需要 64 个二进制位全部都用来存储指针。</p> <p>isa 的结构：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">// x86_64 架构</span>
<span class="token keyword">struct</span> <span class="token punctuation">{</span>
    uintptr_t nonpointer        <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 0:普通指针，1:优化过，使用位域存储更多信息</span>
    uintptr_t has_assoc         <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 对象是否含有或曾经含有关联引用</span>
    uintptr_t has_cxx_dtor      <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 表示是否有C++析构函数或OC的dealloc</span>
    uintptr_t shiftcls          <span class="token operator">:</span> <span class="token number">44</span><span class="token punctuation">;</span> <span class="token comment">// 存放着 Class、Meta-Class 对象的内存地址信息</span>
    uintptr_t magic             <span class="token operator">:</span> <span class="token number">6</span><span class="token punctuation">;</span>  <span class="token comment">// 用于在调试时分辨对象是否未完成初始化</span>
    uintptr_t weakly_referenced <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 是否被弱引用指向</span>
    uintptr_t deallocating      <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 对象是否正在释放</span>
    uintptr_t has_sidetable_rc  <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 是否需要使用 sidetable 来存储引用计数</span>
    uintptr_t extra_rc          <span class="token operator">:</span> <span class="token number">8</span><span class="token punctuation">;</span>  <span class="token comment">// 引用计数能够用 8 个二进制位存储时，直接存储在这里</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// arm64 架构</span>
<span class="token keyword">struct</span> <span class="token punctuation">{</span>
    uintptr_t nonpointer        <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 0:普通指针，1:优化过，使用位域存储更多信息</span>
    uintptr_t has_assoc         <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 对象是否含有或曾经含有关联引用</span>
    uintptr_t has_cxx_dtor      <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 表示是否有C++析构函数或OC的dealloc</span>
    uintptr_t shiftcls          <span class="token operator">:</span> <span class="token number">33</span><span class="token punctuation">;</span> <span class="token comment">// 存放着 Class、Meta-Class 对象的内存地址信息</span>
    uintptr_t magic             <span class="token operator">:</span> <span class="token number">6</span><span class="token punctuation">;</span>  <span class="token comment">// 用于在调试时分辨对象是否未完成初始化</span>
    uintptr_t weakly_referenced <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 是否被弱引用指向</span>
    uintptr_t deallocating      <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 对象是否正在释放</span>
    uintptr_t has_sidetable_rc  <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 是否需要使用 sidetable 来存储引用计数</span>
    uintptr_t extra_rc          <span class="token operator">:</span> <span class="token number">19</span><span class="token punctuation">;</span>  <span class="token comment">// 引用计数能够用 19 个二进制位存储时，直接存储在这里</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>这里的 has_sidetable_rc 和 extra_rc，has_sidetable_rc 表明该指针是否引用了 sidetable 散列表，之所以有这个选项，是因为少量的引用计数是不会直接存放在 SideTables 表中的，对象的引用计数会先存放在 extra_rc 中，当其被存满时，才会存入相应的 SideTables 散列表中，SideTables 中有很多张 SideTable，每个 SideTable 也都是一个散列表，而引用计数表就包含在 SideTable 之中。</p></li> <li><p>散列表（引用计数表、弱引用表）</p> <p>引用计数要么存放在 isa 的 extra_rc 中，要么存放在引用计数表中，而引用计数表包含在一个叫 SideTable 的结构中，它是一个散列表，也就是哈希表。而 SideTable 又包含在一个全局的 StripeMap 的哈希映射表中，这个表的名字叫 SideTables。</p> <p>当一个对象访问 SideTables 时：</p> <ul><li><p>首先会取得对象的地址，将地址进行哈希运算，与 SideTables 中 SideTable 的个数取余，最后得到的结果就是该对象所要访问的 SideTable</p></li> <li><p>在取得的 SideTable 中的 RefcountMap 表中再进行一次哈希查找，找到该对象在引用计数表中对应的位置</p></li> <li><p>如果该位置存在对应的引用计数，则对其进行操作，如果没有对应的引用计数，则创建一个对应的 size_t 对象，其实就是一个 uint 类型的无符号整型</p></li></ul> <p>弱引用表也是一张哈希表的结构，其内部包含了每个对象对应的弱引用表 weak_entry_t，而 weak_entry_t 是一个结构体数组，其中包含的则是每一个对象弱引用的对象所对应的弱引用指针。</p></li></ul> <h2 id="_11-循环引用"><a href="#_11-循环引用" class="header-anchor">#</a> 11.循环引用</h2> <p>循环引用的实质：多个对象相互之间有强引用，不能释放让系统回收。</p> <p>如何解决循环引用？</p> <p>1、避免产生循环引用，通常是将 strong 引用改为 weak 引用。 比如在修饰属性时用weak 在block内调用对象方法时，使用其弱引用，这里可以使用两个宏</p> <p>#define WS(weakSelf)            __weak __typeof(&amp;*self)weakSelf = self; // 弱引用</p> <p>#define ST(strongSelf)          __strong __typeof(&amp;*self)strongSelf = weakSelf; //使用这个要先声明weakSelf
还可以使用__block来修饰变量 在MRC下，__block不会增加其引用计数，避免了循环引用 在ARC下，__block修饰对象会被强引用，无法避免循环引用，需要手动解除。</p> <p>2、在合适时机去手动断开循环引用。 通常我们使用第一种。</p> <ul><li><p>代理(delegate)循环引用属于相互循环引用</p> <p>delegate 是iOS中开发中比较常遇到的循环引用，一般在声明delegate的时候都要使用弱引用 weak,或者assign,当然怎么选择使用assign还是weak，MRC的话只能用assign，在ARC的情况下最好使用weak，因为weak修饰的变量在释放后自动指向nil，防止野指针存在</p></li> <li><p>NSTimer循环引用属于相互循环使用</p> <p>在控制器内，创建NSTimer作为其属性，由于定时器创建后也会强引用该控制器对象，那么该对象和定时器就相互循环引用了。 如何解决呢？ 这里我们可以使用手动断开循环引用： 如果是不重复定时器，在回调方法里将定时器invalidate并置为nil即可。 如果是重复定时器，在合适的位置将其invalidate并置为nil即可</p></li></ul> <p>3、block循环引用</p> <p>一个简单的例子：</p> <div class="language-c extra-class"><pre class="language-c"><code>@<span class="token function">property</span> <span class="token punctuation">(</span>copy<span class="token punctuation">,</span> nonatomic<span class="token punctuation">)</span> dispatch_block_t myBlock<span class="token punctuation">;</span>
@<span class="token function">property</span> <span class="token punctuation">(</span>copy<span class="token punctuation">,</span> nonatomic<span class="token punctuation">)</span> NSString <span class="token operator">*</span>blockString<span class="token punctuation">;</span>

<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>testBlock <span class="token punctuation">{</span>
    self<span class="token punctuation">.</span>myBlock <span class="token operator">=</span> <span class="token operator">^</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">NSLog</span><span class="token punctuation">(</span>@<span class="token string">&quot;%@&quot;</span><span class="token punctuation">,</span>self<span class="token punctuation">.</span>blockString<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>由于block会对block中的对象进行持有操作,就相当于持有了其中的对象，而如果此时block中的对象又持有了该block，则会造成循环引用。 解决方案就是使用__weak修饰self即可</p> <div class="language-c extra-class"><pre class="language-c"><code>__weak <span class="token keyword">typeof</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> weakSelf <span class="token operator">=</span> self<span class="token punctuation">;</span>

self<span class="token punctuation">.</span>myBlock <span class="token operator">=</span> <span class="token operator">^</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">NSLog</span><span class="token punctuation">(</span>@<span class="token string">&quot;%@&quot;</span><span class="token punctuation">,</span>weakSelf<span class="token punctuation">.</span>blockString<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>并不是所有block都会造成循环引用。 只有被强引用了的block才会产生循环引用 而比如dispatch_async(dispatch_get_main_queue(), ^{}),[UIView animateWithDuration:1 animations:^{}]这些系统方法等 或者block并不是其属性而是临时变量,即栈block</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token punctuation">[</span>self testWithBlock<span class="token operator">:</span><span class="token operator">^</span><span class="token punctuation">{</span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span>@<span class="token string">&quot;%@&quot;</span><span class="token punctuation">,</span>self<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>testWithBlock<span class="token operator">:</span><span class="token punctuation">(</span>dispatch_block_t<span class="token punctuation">)</span>block <span class="token punctuation">{</span>
    <span class="token function">block</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>还有一种场景，在block执行开始时self对象还未被释放，而执行过程中，self被释放了，由于是用weak修饰的，那么weakSelf也被释放了，此时在block里访问weakSelf时，就可能会发生错误(向nil对象发消息并不会崩溃，但也没任何效果)。 对于这种场景，应该在block中对 对象使用__strong修饰，使得在block期间对 对象持有，block执行结束后，解除其持有。</p> <div class="language-c extra-class"><pre class="language-c"><code>__weak <span class="token keyword">typeof</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> weakSelf <span class="token operator">=</span> self<span class="token punctuation">;</span>

self<span class="token punctuation">.</span>myBlock <span class="token operator">=</span> <span class="token operator">^</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

        __strong <span class="token function">__typeof</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> strongSelf <span class="token operator">=</span> weakSelf<span class="token punctuation">;</span>

        <span class="token punctuation">[</span>strongSelf test<span class="token punctuation">]</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/technology-stack/docs/iOS/Image-processing.html" class="prev">
        图像处理
      </a></span> <span class="next"><a href="/technology-stack/docs/iOS/Message-passing.html">
        消息传递的方式
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/technology-stack/assets/js/app.33e0f0b6.js" defer></script><script src="/technology-stack/assets/js/2.fe7261c1.js" defer></script><script src="/technology-stack/assets/js/26.8a472b4b.js" defer></script>
  </body>
</html>
